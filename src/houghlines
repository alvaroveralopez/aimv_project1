import cv2 as cv
import numpy as np
import sys
import skimage
from functools import partial  
from skimage import filters
import math
import pandas as pn
from matplotlib import pyplot as plt
import tkinter as tk
from tkinter import filedialog
import glob
global edges

import os
# Global variables (be careful because variables in this list are used in the functions, 
# so these functions can not be copied to another program as they are here...you would need to modify them)


window_name = "Edge Map"
standard_name = "Standard Hough Lines Demo"
min_threshold = 50
alpha = 1000


def Standard_Hough(edges):
    standard_hough = cv.cvtColor(edges, cv.COLOR_GRAY2BGR) #make a copy
    # Use Standard Hough Transform
    s_lines = cv.HoughLines(edges, 1, np.pi / 90, min_threshold )
    print(f"{s_lines}")
    
    # Show the result
    for line in s_lines:
        r = line[0][0]
        t = line[0][1]
        a = np.cos(t)
        b = np.sin(t)
        x0 = a * r
        y0 = b * r
        pt1 = (round(x0 - alpha * b), round(y0 + alpha * a))
        pt2 = (round(x0 + alpha * b), round(y0 - alpha * a))
        cv.line(standard_hough, pt1, pt2, (255, 0, 0), 2)
        print(f"Houghlines: Rho {r}, Theta: {t}, Point1: {pt1}, Point2: {pt2}")

    cv.imshow(standard_name, standard_hough)
    return s_lines


#########################
###  Main program #######
bgModel_RGB = cv.createBackgroundSubtractorMOG2()
imgRGB = cv.imread('C:/Users/Usuario/Desktop/AIMV/Project I/Basic Bricks/tcol1.bmp')

#print(f"\n\n\nimRGB: {imgRGB}\n\n\n")
edges = cv.cvtColor(imgRGB, cv.COLOR_BGR2GRAY)
edges1 = cv.GaussianBlur(edges, (31, 31), 4)
edges = cv.Canny(edges1, 40, 50, 3)
cv.imshow('frame', imgRGB)  # Mostrar los fotogramas del video
cv.waitKey(0)
cv.destroyAllWindows()
cv.imshow('edges', edges)  # Mostrar los bordes del video
cv.waitKey(0)
cv.destroyAllWindows()
a=edges
lines=Standard_Hough(edges)
print("holi")
cv.waitKey(0)

parallel_lines = []
perpendicular_lines = []
edges1 = cv.cvtColor(edges, cv.COLOR_BGR2GRAY)
# Tolerancia para considerar ángulos cercanos a 90 grados
angle_tolerance = 10

# Identificar líneas paralelas y perpendiculares
for i in range(len(lines)):
    for j in range(i + 1, len(lines)):
        rho1, theta1 = lines[i][0]
        rho2, theta2 = lines[j][0]
        angle1_degrees = np.degrees(theta1)
        angle2_degrees = np.degrees(theta2)

        # Calcular la diferencia de ángulo
        angle_difference = abs(angle1_degrees - angle2_degrees)

        if abs(angle_difference - 90) < angle_tolerance:
            # Las líneas son perpendiculares
            perpendicular_lines.append((rho1, theta1, rho2, theta2))
        elif abs(angle_difference) < angle_tolerance:
            # Las líneas son paralelas
            parallel_lines.append((rho1, theta1, rho2, theta2))

# Seleccionar un par de líneas paralelas y un par de líneas perpendiculares
if len(parallel_lines) >= 2 and len(perpendicular_lines) >= 2:
    selected_parallel_pair = parallel_lines[:2]
    selected_perpendicular_pair = perpendicular_lines[:2]

    # Dibujar las líneas de los pares seleccionados en la imagen original
    for pair in selected_parallel_pair + selected_perpendicular_pair:
        rho1, theta1, rho2, theta2 = pair
        a1 = np.cos(theta1)
        b1 = np.sin(theta1)
        x1 = a1 * rho1
        y1 = b1 * rho1
        a2 = np.cos(theta2)
        b2 = np.sin(theta2)
        x2 = a2 * rho2
        y2 = b2 * rho2

        # Dibuja las líneas en la imagen
        cv.line(edges1, (int(x1), int(y1)), (int(x2), int(y2)), (0, 0, 255), 2)

# Mostrar la imagen con las líneas seleccionadas
cv.imshow('Líneas Seleccionadas', edges1)
cv.waitKey(0)
cv.destroyAllWindows()
